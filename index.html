<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kalita Wave Timer</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #3A2114; /* Logo Background Color */
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            transition: background-color 0.5s ease;
            text-align: center;
            overflow: hidden; /* Prevent scrolling during flashing */
        }

        #timer {
            font-size: 5rem;
            font-weight: bold;
            font-variant-numeric: tabular-nums;
            margin-bottom: 20px;
            z-index: 10;
        }

        #instruction {
            font-size: 2rem;
            margin-bottom: 20px;
            padding: 0 20px;
            min-height: 3em; /* Reserve space for text */
            z-index: 10;
        }

        #clock-container {
            position: relative;
            width: 300px;
            height: 300px;
            margin-bottom: 30px;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #action-btn {
            background-color: #4CAF50; /* Green */
            border: none;
            color: white;
            padding: 20px 40px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.1s, background-color 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            z-index: 10;
        }

        #action-btn:active {
            transform: scale(0.95);
        }

        #action-btn.reset {
            background-color: #f44336; /* Red */
        }

        /* Flashing Animation (Alarm) */
        @keyframes flash-alarm {
            0% { background-color: #f44336; }
            50% { background-color: #000000; }
            100% { background-color: #f44336; }
        }

        /* Pulsing Animation (Warning) */
        @keyframes pulse-warning {
            0% { background-color: var(--bg-color); }
            50% { background-color: #ff9800; } /* Orange warning */
            100% { background-color: var(--bg-color); }
        }

        .flashing {
            animation: flash-alarm 0.5s infinite;
        }

        .warning {
            animation: pulse-warning 1s infinite;
        }

        .step-dots {
            margin-top: 30px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .dot {
            width: 10px;
            height: 10px;
            background-color: #555;
            border-radius: 50%;
        }
        .dot.active {
            background-color: #fff;
            transform: scale(1.2);
        }

        #start-counter {
            margin-top: 16px;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 1px;
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="instruction">Ready to Brew</div>
    
    <div id="clock-container">
        <canvas id="clock" width="300" height="300"></canvas>
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 5;">
            <img src="logo.png" alt="The Sent Coffee" style="width: 106px; margin-bottom: 5px; opacity: 0.8; border-radius: 5px;">
            <div id="timer" style="font-size: 3.5rem; margin: 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">0:00</div>
        </div>
    </div>

    <button id="action-btn" onclick="toggleTimer()">START</button>
    
    <div id="start-counter">Brews started: 0</div>

    <div class="step-dots" id="dots-container">
        <!-- Dots generated by JS -->
    </div>

    <div id="step-list" style="margin-top: 20px; text-align: left; width: 80%; max-width: 300px; font-size: 1rem; opacity: 0.9;">
        <!-- Steps generated by JS -->
    </div>

    <script>
        // --- Configuration ---
        const schedule = [
            { time: 0, text: "Pour Water (Bloom)", color: "#8d6e63" }, 
            { time: 30, text: "Pour Water (1st Pour)", color: "#5d4037" }, 
            { time: 90, text: "Pour Water (2nd Pour)", color: "#4e342e" }, 
            { time: 150, text: "Pour Water (Final Pour)", color: "#3e2723" }, 
            { time: 180, text: "Remove Dripper!", color: "#f44336", final: true } 
        ];

        // --- State ---
        let startTime = null;
        let displayOffset = 0; // Time to subtract from display
        let timerInterval = null;
        let isRunning = false;
        let currentStepIndex = -1;
        let warningActive = false;
        let startCount = parseInt(localStorage.getItem('brewStartCount') || '0', 10);
        
        // --- Elements ---
        const timerDisplay = document.getElementById('timer');
        const instructionDisplay = document.getElementById('instruction');
        const actionBtn = document.getElementById('action-btn');
        const body = document.body;
        const dotsContainer = document.getElementById('dots-container');
        const startCounterDisplay = document.getElementById('start-counter');
        const stepListContainer = document.getElementById('step-list');
        const canvas = document.getElementById('clock');
        const ctx = canvas.getContext('2d');

        // --- Init Steps UI ---
        function renderStepList() {
            stepListContainer.innerHTML = '';
            schedule.forEach((step, index) => {
                const div = document.createElement('div');
                div.id = `step-row-${index}`;
                div.style.padding = "8px";
                div.style.borderBottom = "1px solid rgba(255,255,255,0.1)";
                div.style.display = "flex";
                div.style.justifyContent = "space-between";
                div.style.color = "#888"; // Inactive color
                
                // Format time (M:SS)
                const m = Math.floor(step.time / 60);
                const s = step.time % 60;
                const timeStr = `${m}:${s.toString().padStart(2, '0')}`;

                div.innerHTML = `<span>${step.text}</span> <span style="font-family: monospace;">${timeStr}</span>`;
                stepListContainer.appendChild(div);
            });
        }
        
        // Call init immediately
        renderStepList();
        startCounterDisplay.innerText = `Brews started: ${startCount}`;

        // --- Audio Context ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playBeep(type) {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'tick') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); 
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'warning') {
                // Soft double blip for warning
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); 
                gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
                
                const osc2 = audioCtx.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(440, audioCtx.currentTime + 0.2); 
                const gain2 = audioCtx.createGain();
                gain2.gain.setValueAtTime(0.05, audioCtx.currentTime + 0.2);
                osc2.connect(gain2);
                gain2.connect(audioCtx.destination);
                osc2.start(audioCtx.currentTime + 0.2);
                osc2.stop(audioCtx.currentTime + 0.3);

            } else if (type === 'alarm') {
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 1.0);

                setTimeout(() => {
                   const osc2 = audioCtx.createOscillator();
                   const gain2 = audioCtx.createGain();
                   osc2.connect(gain2);
                   gain2.connect(audioCtx.destination);
                   osc2.type = 'triangle';
                   osc2.frequency.setValueAtTime(523.25, audioCtx.currentTime);
                   gain2.gain.setValueAtTime(0.3, audioCtx.currentTime);
                   gain2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
                   osc2.start();
                   osc2.stop(audioCtx.currentTime + 1.0);
                }, 400);
            }
        }

        // --- Clock Drawing ---
        function drawClock(elapsedSecs) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 140;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Determine current step range for progress bar
            let stepStart = 0;
            let stepEnd = 30; // Default first step
            
            for (let i = 0; i < schedule.length; i++) {
                if (elapsedSecs >= schedule[i].time) {
                    stepStart = schedule[i].time;
                    if (i + 1 < schedule.length) {
                        stepEnd = schedule[i+1].time;
                    } else {
                        stepEnd = schedule[i].time + 60; // Just visual filler for last step
                    }
                }
            }

            // Calculate progress for current step (0.0 to 1.0)
            const stepDuration = stepEnd - stepStart;
            const stepElapsed = elapsedSecs - stepStart;
            let progress = Math.min(Math.max(stepElapsed / stepDuration, 0), 1);

            // --- Water Fill Animation ---
            // Create a clipping region for the circle so water stays inside
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 15, 0, 2 * Math.PI); // Slightly smaller than ring
            ctx.clip();

            // Calculate water height based on progress (from bottom up)
            // Height moves from (centerY + radius) to (centerY - radius)
            const waterLevel = (centerY + radius) - (progress * (radius * 2));
            
            // Draw Wave
            const time = Date.now() / 200; // Animation speed
            ctx.fillStyle = 'rgba(76, 175, 80, 0.3)'; // Semi-transparent green water
            ctx.beginPath();
            
            // Start at left edge
            ctx.moveTo(centerX - radius, waterLevel);
            
            // Draw sine wave across
            for (let x = centerX - radius; x <= centerX + radius; x += 10) {
                const y = waterLevel + Math.sin(x / 20 + time) * 5; // Wave amplitude
                ctx.lineTo(x, y);
            }
            
            // Fill down to bottom
            ctx.lineTo(centerX + radius, centerY + radius);
            ctx.lineTo(centerX - radius, centerY + radius);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // --- Draw Ring (Existing) ---
            // Draw Background Circle (Track)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.lineWidth = 15;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.stroke();
            
            // Draw Progress Arc
            const startAngle = -0.5 * Math.PI; // 12 o'clock
            const endAngle = startAngle + (2 * Math.PI * progress);

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngle, endAngle);
            ctx.lineWidth = 15;
            ctx.strokeStyle = '#4CAF50'; // Green progress
            ctx.lineCap = 'round';
            ctx.stroke();
        }

        // --- Timer Logic ---
        function toggleTimer() {
            if (isRunning) {
                resetTimer();
            } else {
                startTimer();
            }
        }

        function startTimer() {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            startCount++;
            localStorage.setItem('brewStartCount', startCount);
            startCounterDisplay.innerText = `Brews started: ${startCount}`;

            isRunning = true;
            startTime = Date.now();
            displayOffset = 0;
            actionBtn.innerText = "RESET";
            actionBtn.classList.add('reset');
            currentStepIndex = -1;
            
            dotsContainer.innerHTML = '';
            schedule.forEach(() => {
                const dot = document.createElement('div');
                dot.classList.add('dot');
                dotsContainer.appendChild(dot);
            });

            timerInterval = setInterval(updateTimer, 50); // Faster refresh for smooth clock
            updateTimer(); 
        }

        function resetTimer() {
            isRunning = false;
            clearInterval(timerInterval);
            timerDisplay.innerText = "0:00";
            instructionDisplay.innerText = "Ready to Brew";
            body.style.backgroundColor = "#1a1a1a";
            body.style.setProperty('--bg-color', '#1a1a1a');
            body.classList.remove('flashing');
            body.classList.remove('warning');
            actionBtn.innerText = "START";
            actionBtn.classList.remove('reset');
            dotsContainer.innerHTML = '';
            displayOffset = 0;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            renderStepList(); // Reset list
        }

        function updateTimer() {
            const elapsedMs = Date.now() - startTime;
            const elapsedSecs = elapsedMs / 1000; // Float for smooth clock
            const elapsedInt = Math.floor(elapsedSecs);

            // Auto-Reset after 4 minutes (240 seconds)
            if (elapsedInt >= 240) {
                resetTimer();
                return;
            }

            // Check Schedule
            let activeStepIdx = -1;
            for (let i = schedule.length - 1; i >= 0; i--) {
                if (elapsedInt >= schedule[i].time) {
                    activeStepIdx = i;
                    break;
                }
            }
            
            // Look ahead for warning (10s before next step)
            // Only warn if we are NOT in the final step
            if (activeStepIdx < schedule.length - 1 && activeStepIdx >= 0) {
                 const nextStepTime = schedule[activeStepIdx + 1].time;
                 const timeLeft = nextStepTime - elapsedSecs;
                 
                 if (timeLeft <= 10 && timeLeft > 0) {
                     body.classList.add('warning');
                     // Beep once when warning starts (at exactly 10s left)
                     if (Math.abs(timeLeft - 10) < 0.1) {
                         playBeep('warning');
                     }
                 } else {
                     body.classList.remove('warning');
                 }
            }

            // Step Change Logic
            if (activeStepIdx > currentStepIndex) {
                currentStepIndex = activeStepIdx;
                const step = schedule[currentStepIndex];
                
                body.classList.remove('warning'); 

                if (step.resetDisplay) {
                    displayOffset = step.time;
                }

                instructionDisplay.innerText = step.text;
                body.style.backgroundColor = step.color;
                body.style.setProperty('--bg-color', step.color); 
                
                // Update Dots
                const dots = document.querySelectorAll('.dot');
                dots.forEach((d, i) => {
                    if (i <= currentStepIndex) d.classList.add('active');
                });

                // Update List Highlight
                schedule.forEach((_, i) => {
                    const row = document.getElementById(`step-row-${i}`);
                    if (i === currentStepIndex) {
                        row.style.color = "#fff"; // Active
                        row.style.fontWeight = "bold";
                        row.style.backgroundColor = "rgba(255,255,255,0.1)";
                        row.style.borderRadius = "5px";
                    } else if (i < currentStepIndex) {
                        row.style.color = "#aaa"; // Past
                        row.style.fontWeight = "normal";
                        row.style.backgroundColor = "transparent";
                        row.style.textDecoration = "line-through";
                        row.style.opacity = "0.5";
                    } else {
                        row.style.color = "#666"; // Future
                        row.style.fontWeight = "normal";
                        row.style.backgroundColor = "transparent";
                        row.style.textDecoration = "none";
                    }
                });

                if (step.final) {
                    playBeep('alarm');
                    body.classList.add('flashing');
                } else {
                    playBeep('tick');
                }
            }
            
            // Update Display
            let displaySecs = Math.max(0, elapsedSecs - displayOffset);
            const m = Math.floor(displaySecs / 60);
            const s = Math.floor(displaySecs % 60);
            timerDisplay.innerText = `${m}:${s.toString().padStart(2, '0')}`;

            // Update Clock
            drawClock(elapsedSecs);
        }
    </script>
</body>
</html>
